CREATE TABLE IotInput(
  eventEnqueuedUtcTime datetime,
  sensorId nvarchar(max),
  value float
);

CREATE TABLE SensorJobExecutionsReferenceInput(
  sensorId nvarchar(max),
  jobId nvarchar(max),
  jobDataAreaId nvarchar(max),
  isJobCompleted nvarchar(max),
  jobRegistrationStartDateTime datetime,
  jobRegistrationStopDateTime datetime,
  jobLastRegistrationDateTime datetime,
  productionRateDeviationThreshold float,
  requestedQuantity float,
  processingTimeInHours float
);

WITH SensorJobExecutionsActualQuantity AS
(
  SELECT
  I.sensorId,
  SUM (I.value) AS actualQuantity,
  MAX(I.eventEnqueuedUtcTime) AS eventEnqueuedUtcTime,
  System.Timestamp AS t
  FROM IotInput I
  TIMESTAMP BY I.eventEnqueuedUtcTime
  JOIN SensorJobExecutionsReferenceInput R
  ON R.sensorId = I.sensorId
  -- Only consider events that lie between job start and either jobStop or job last reg time
  WHERE I.eventEnqueuedUtcTime >= R.jobRegistrationStartDateTime
  AND (
    (R.isJobCompleted = 'Yes' AND I.eventEnqueuedUtcTime <= R.jobRegistrationStopDateTime)
    OR (R.isJobCompleted = 'No' AND I.eventEnqueuedUtcTime <= R.jobLastRegistrationDateTime))
  GROUP BY HoppingWindow(Duration(hour, 12), Hop(minute, 3)), I.sensorId
),
SensorJobExecutionExpectedAndActualValues AS
(
  SELECT
    IA.sensorId,
    IA.eventEnqueuedUtcTime,
    R.jobId,
    R.jobDataAreaId,
    R.isJobCompleted,
    R.requestedQuantity,
    R.productionRateDeviationThreshold,
    R.processingTimeInHours,
    R.jobRegistrationStartDateTime,
    IA.actualQuantity
  FROM SensorJobExecutionsActualQuantity IA
  JOIN SensorJobExecutionsReferenceInput R
  ON IA.sensorId = R.sensorId
  WHERE DATEDIFF(hour, R.jobRegistrationStartDateTime, IA.t) < R.processingTimeInHours + 1
),
SensorJobExecutionsDelayed AS
(
  SELECT
  sensorId,
  jobId,
  jobDataAreaId,
  isJobCompleted,
  requestedQuantity,
  actualQuantity,
  eventEnqueuedUtcTime,
  CASE
    WHEN isJobCompleted = 'No' AND DATEDIFF(hour, jobRegistrationStartDateTime, System.Timestamp) < processingTimeInHours THEN 0
    WHEN actualQuantity >= requestedQuantity THEN 0
    WHEN actualQuantity < requestedQuantity AND (actualQuantity / requestedQuantity) * 100 < productionRateDeviationThreshold THEN 0
    ELSE 1
  END AS isJobDelayed
  from SensorJobExecutionExpectedAndActualValues
)

SELECT
  CONCAT('ProductionJobDelayed:ActualQuantity:', jobId) AS metricKey,
  DATEDIFF(millisecond, CAST('1970-01-01' as datetime), eventEnqueuedUtcTime) AS uts,
  actualQuantity AS val
INTO MetricOutput
from SensorJobExecutionsDelayed

SELECT
  jobDataAreaId AS dataAreaId,
  sensorId AS machineId,
  jobId AS jobId,
  sensorId AS sensorId,
  actualQuantity AS actualQty,
  requestedQuantity AS expectedQty,
  eventEnqueuedUtcTime AS timestamp,
  eventEnqueuedUtcTime AS sensorTimestamp,
  System.Timestamp AS processingTimestamp,
  'ProductionJobDelayed' AS notificationType
INTO NotificationOutput
FROM SensorJobExecutionsDelayed
WHERE isJobDelayed = 1