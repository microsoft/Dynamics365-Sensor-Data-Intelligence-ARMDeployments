CREATE TABLE IotInput(
  eventEnqueuedUtcTime datetime,
  sensorId nvarchar(max),
  value float
);

CREATE TABLE SensorJobExecutionsReferenceInput(
  sensorId nvarchar(max),
  jobId nvarchar(max),
  jobDataAreaId nvarchar(max),
  isJobCompleted nvarchar(max),
  jobRegistrationStartDateTime datetime,
  jobRegistrationStopDateTime datetime,
  jobLastRegistrationDateTime datetime,
  productionRateDeviationThreshold float,
  requestedQuantity float,
  processingTimeInHours float
);

WITH SensorJobExecutionsActualQuantity AS
(
  SELECT
  I.sensorId,
  SUM (I.value) AS actualQuantity
  FROM IotInput I
  TIMESTAMP BY I.eventEnqueuedUtcTime
  GROUP BY TumblingWindow(minute, 3), I.sensorId
),
SensorJobExecutionExpectedAndActualValues AS
(
  SELECT
    I.sensorId,
    I.eventEnqueuedUtcTime,
    R.jobId,
    R.jobDataAreaId,
    R.isJobCompleted,
    R.requestedQuantity,
    R.productionRateDeviationThreshold,
    R.processingTimeInHours,
    R.jobLastRegistrationDateTime,
    IA.actualQuantity
  FROM IotInput I
  TIMESTAMP BY I.eventEnqueuedUtcTime
  JOIN SensorJobExecutionsReferenceInput R
  ON I.sensorId = R.sensorId
  JOIN SensorJobExecutionsActualQuantity IA
  ON IA.sensorId = R.sensorId
  -- Only consider events that lie between job start and either jobStop or job last reg time
  WHERE I.eventEnqueuedUtcTime >= R.jobRegistrationStartDateTime
  AND (
    (R.isJobCompleted = 1 AND I.eventEnqueuedUtcTime >= R.jobLastRegistrationDateTime)
    OR (R.isJobCompleted = 0 AND I.eventEnqueuedUtcTime >= R.jobLastRegistrationDateTime))
  GROUP BY I.value, TumblingWindow(hour, 3)
),
SensorJobExecutionsDelayed AS
(
  SELECT
  sensorId,
  jobId,
  jobDataAreaId,
  isJobCompleted,
  requestedQuantity,
  actualQuantity,
  CASE
    WHEN isJobCompleted = 0 AND DATEDIFF(hour, jobLastRegistrationDateTime, eventEnqueuedUtcTime) < processingTimeInHours THEN 0
    WHEN actualQuantity >= requestedQuantity THEN 0
    WHEN actualQuantity < requestedQuantity AND (actualQuantity / requestedQuantity) * 100 > productionRateDeviationThreshold THEN 0
    ELSE 1
  END AS isJobDelayed
  from SensorJobExecutionExpectedAndActualValues
)

SELECT
  CONCAT('ProductionJobDelayed:ActualQuantity', jobId) AS metricKey,
  DATEDIFF(millisecond, CAST('1970-01-01' as datetime), eventEnqueuedUtcTime) AS uts,
  actualQuantity AS val
INTO MetricOutput
from SensorJobItemBatchAttributeValues

SELECT
  jobDataAreaId AS dataAreaId,
  sensorId AS machineId,
  jobId AS jobId,
  sensorId AS sensorId,
  actualQuantity AS actualQty,
  requestedQuantity AS expectedQty,
  eventEnqueuedUtcTime AS timestamp,
  eventEnqueuedUtcTime AS sensorTimestamp,
  System.Timestamp AS processingTimestamp,
  'ProductionJobDelayed' AS notificationType
INTO NotificationOutput
FROM SensorJobExecutionsDelayed
WHERE isJobDelayed = 1